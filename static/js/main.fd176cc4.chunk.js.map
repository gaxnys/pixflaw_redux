{"version":3,"sources":["actions/index.js","constants.js","reducers/player.js","utils/trig.js","utils/random.js","reducers/level.js","reducers/index.js","components/index.js","components/Player.js","components/Map.js","index.js"],"names":["touches","windowWidth","windowHeight","type","constants","ACCELERATION","JUMP_ACCELERATION","RUN_ACCELERATION","VELOCITY_LOSS","PLANET_MASS","PLAYER_WIDTH","PLAYER_HEIGHT","PLATFORM_SIDE","SPEED_LIMIT","DOWN_CONSTANT","POINTS","BACKGROUND_RADIUS","LEVEL_RADIUS","PLANET_RADIUS","PLATFORMS","CAMERA_INERTIA","TOUCH_DEBOUNCE_LIMIT","FLY_ACCELERATION","GROUND_FRICTION","AIR_FRICTION","keyToDirection","calculateAcceleration","keys","posR","colliding","accAngle","accR","verticalAcc","horizontalAcc","Math","atan","r","pow","angle","checkCollisions","posAngle","platforms","sides","up","left","down","right","almost","playerWidthPlatform","playerAnglePlatform","playerHeightPlatform","platform","radiusDiff","angleDiff","PI","abs","tan","player","newKeys","state","Set","velR","velAngle","cameraR","cameraAngle","debounce","action","levelState","add","key","Object","assign","delete","length","has","clientX","collisions","level","collidingIsh","planetRadius","newAcc","newVelR","min","newPosR","friction","newVelAngle","frictionAcc","sign","newPosAngle","newCameraR","newCameraAngle","newDebounce","size","pointsInCircle","numPoints","maxRadius","minRadius","minDistance","uniform","points","u","random","radius","posX","round","cos","posY","sin","clear","point","push","getPlanetRadius","wins","getGoalRadius","generateLevel","defaultState","goalRadius","newWins","rootReducer","Component","getState","this","context","document","createElement","getContext","currentValue","undefined","updateCanvas","updatePosition","previousValue","shouldCanvasUpdate","shouldPositionUpdate","Error","Player","fillStyle","canvas","clearRect","width","height","save","translate","rotate","fillRect","restore","offsetX","offsetY","scale","i","y","floor","x","Map","store","components","center","randoms","renderPlatforms","beginPath","arc","fill","strokeStyle","lineWidth","stroke","root","getElementById","window","innerWidth","innerHeight","onresize","event","appendChild","init","createLogger","predicate","createStore","componentInstances","map","component","render","reduce","shouldUpdate","componentInstance","shouldComponentUpdate","rotation","renderToContext","requestAnimationFrame","animationTicker","timestamp","setInterval","dispatch","onkeydown","onkeyup","body","addEventListener","preventDefault","passive"],"mappings":"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","file":"static/js/main.fd176cc4.chunk.js","sourcesContent":["export const RENDER_TICK = 'RENDER_TICK'\nexport const renderTick = () => ({\n    type: RENDER_TICK\n})\n\nexport const GAME_TICK = 'GAME_TICK'\nexport const gameTick = (scale) => ({\n    type: GAME_TICK,\n    scale\n})\n\nexport const KEY_DOWN = 'KEY_DOWN'\nexport const keyDown = (key) => ({\n    type: KEY_DOWN,\n    key\n})\n\nexport const KEY_UP = 'KEY_UP'\nexport const keyUp = (key) => ({\n    type: KEY_UP,\n    key\n})\n\nexport const TOUCHES = 'TOUCHES'\nexport const touches = (touches, windowWidth, windowHeight) => ({\n    type: TOUCHES,\n    touches,\n    windowWidth,\n    windowHeight\n})\n\nexport const LEVEL_WIN = 'LEVEL_WIN'\nexport const levelWin = () => ({\n    type: LEVEL_WIN\n})\n\nexport const RESET_LEVEL = 'RESET_LEVEL'\nexport const resetLevel = () => ({\n    type: RESET_LEVEL\n})\n","const constants = {\n    ACCELERATION: 0.3,\n    JUMP_ACCELERATION: 3,\n    RUN_ACCELERATION: 0.1,\n    VELOCITY_LOSS: 10,\n    PLANET_MASS: 400000,\n    PLAYER_WIDTH: 20,\n    PLAYER_HEIGHT: 30,\n    PLATFORM_SIDE: 40,\n    SPEED_LIMIT: 10,\n    DOWN_CONSTANT: 0.1,\n\n    POINTS: 20000,\n    BACKGROUND_RADIUS: 4000,\n    LEVEL_RADIUS: 4000,\n    PLANET_RADIUS: 3000,\n    PLATFORMS: 1000,\n    CAMERA_INERTIA: 20,\n\n    TOUCH_DEBOUNCE_LIMIT: 10,\n}\n\nconstants.FLY_ACCELERATION = constants.RUN_ACCELERATION / 2\nconstants.GROUND_FRICTION = constants.RUN_ACCELERATION / 2\nconstants.AIR_FRICTION = constants.GROUND_FRICTION / 2\n\nexport default constants\n","import {\n    GAME_TICK,\n    KEY_DOWN,\n    KEY_UP,\n    TOUCHES,\n    LEVEL_WIN,\n} from '../actions/index'\nimport constants from '../constants.js'\nimport { normalize } from '../utils/trig'\n\nconst keyToDirection = {\n    \"w\": \"up\",\n    \"ArrowUp\": \"up\",\n    \"a\": \"left\",\n    \"ArrowLeft\": \"left\",\n    \"s\": \"down\",\n    \"ArrowDown\": \"down\",\n    \"d\": \"right\",\n    \"ArrowRight\": \"right\",\n    \" \": \"up\",\n}\n\nconst calculateAcceleration = (keys, posR, colliding) => {\n    var accAngle = 0, accR = colliding ? 0 : -constants.DOWN_CONSTANT\n    var verticalAcc = 0\n    var horizontalAcc = constants.FLY_ACCELERATION\n    if(colliding) {\n        verticalAcc = constants.JUMP_ACCELERATION\n        horizontalAcc = constants.RUN_ACCELERATION\n    } else {\n        verticalAcc = constants.DOWN_CONSTANT\n    }\n    for(const key of keys){\n        switch(key) {\n            case \"up\":\n                accR += verticalAcc\n                break\n\n            case \"left\":\n                accAngle += Math.atan(horizontalAcc / posR)\n                break\n\n            case \"right\":\n                accAngle -= Math.atan(horizontalAcc / posR)\n                break\n\n            default:\n                break\n        }\n    }\n\n    accR -= constants.PLANET_MASS / Math.pow(posR, 2)\n\n    return { r: accR, angle: accAngle }\n}\n\nconst checkCollisions = (posR, posAngle, platforms) => {\n    var sides = { up: false, left: false, down: false, right: false, almost: false }\n    const playerWidthPlatform = constants.PLAYER_WIDTH / 2 + constants.PLATFORM_SIDE / 2\n    const playerAnglePlatform = Math.atan(playerWidthPlatform / posR)\n    const playerHeightPlatform = constants.PLAYER_HEIGHT / 2 + constants.PLATFORM_SIDE / 2\n    for(const platform of platforms) {\n        const radiusDiff = platform.r - posR\n        const angleDiff = normalize(platform.angle - posAngle)\n\n        sides.almost = sides.almost || (\n            Math.abs(radiusDiff) < playerHeightPlatform + 1 &&\n            Math.abs(angleDiff) < Math.atan((playerWidthPlatform - 3) / posR) &&\n            radiusDiff < 0)\n\n        if(Math.abs(radiusDiff) > playerHeightPlatform) {\n            continue\n        }\n        if(Math.abs(angleDiff) > playerAnglePlatform) {\n            continue\n        }\n        if(playerHeightPlatform - Math.abs(radiusDiff) <\n            playerWidthPlatform - Math.abs(posR * Math.tan(angleDiff))\n        ) {\n            if(radiusDiff >= 0)\n                sides.up = sides.up || Math.abs(radiusDiff) - playerHeightPlatform\n            else\n                sides.down = sides.down || playerHeightPlatform - Math.abs(radiusDiff)\n        } else {\n            if(angleDiff >= 0)\n                sides.left = sides.left || Math.abs(angleDiff) - playerAnglePlatform\n            else\n                sides.right = sides.right || playerAnglePlatform - Math.abs(angleDiff)\n        }\n    }\n    return sides\n}\n\nconst player = (\n    state = { keys: new Set(),\n              velR: 0, velAngle: 0,\n              posR: 3100, posAngle: Math.PI/2,\n              cameraR: 3100, cameraAngle: Math.PI/2,\n              debounce: 0\n    }, action, levelState\n) => {\n    var newKeys\n    switch(action.type) {\n    case KEY_DOWN:\n        newKeys = new Set(state.keys)\n        newKeys.add(keyToDirection[action.key])\n        return Object.assign({}, state, { keys: newKeys })\n\n    case KEY_UP:\n        newKeys = new Set(state.keys)\n        newKeys.delete(keyToDirection[action.key])\n        return Object.assign({}, state, { keys: newKeys })\n\n    case TOUCHES:\n        newKeys = new Set()\n        if(action.touches.length === 2) {\n            if(state.debounce === constants.TOUCH_DEBOUNCE_LIMIT) {\n                newKeys = new Set(state.keys)\n            }\n            newKeys.add(\"up\")\n        } else if(action.touches.length > 0) {\n            if(state.keys.has(\"up\")) {\n                newKeys.add(\"up\")\n            }\n\n            if(action.touches[0].clientX > action.windowWidth / 2) {\n                newKeys.add(\"right\")\n            } else {\n                newKeys.add(\"left\")\n            }\n        }\n\n        return Object.assign({}, state, { keys: newKeys })\n\n    case GAME_TICK:\n        const collisions = checkCollisions(state.posR, state.posAngle, levelState.level)\n        const collidingIsh =\n              (state.posR - constants.PLAYER_HEIGHT / 2 - 1 < levelState.planetRadius) || collisions.almost\n        const newAcc = calculateAcceleration(state.keys, state.posR, collidingIsh)\n\n        var newVelR = Math.min(state.velR + newAcc.r, constants.SPEED_LIMIT)\n        if((collisions.up && state.velR > 0) || (collisions.down && state.velR < 0)) {\n            newVelR = 0\n        }\n        var newPosR = state.posR + newVelR +\n            collisions.down + collisions.up\n\n        if(state.posR - constants.PLAYER_HEIGHT / 2 < levelState.planetRadius) {\n            newPosR = levelState.planetRadius + constants.PLAYER_HEIGHT / 2\n            newVelR = (newVelR < -constants.VELOCITY_LOSS) ? -(newVelR+constants.VELOCITY_LOSS) : 0\n            newVelR = 0\n        }\n\n        const friction = collidingIsh ? constants.GROUND_FRICTION : constants.AIR_FRICTION\n\n        var newVelAngle = state.velAngle + newAcc.angle\n\n        const frictionAcc = Math.sign(-state.velAngle) * friction\n        newVelAngle +=  Math.tan(frictionAcc / state.posR)\n\n        if(Math.abs(newVelAngle) < Math.tan(friction / state.posR)) {\n            newVelAngle = 0\n        }\n\n        if((collisions.left && state.velAngle > 0) || (collisions.right && state.velAngle < 0)) {\n            newVelAngle = 0\n        }\n        var newPosAngle = state.posAngle + newVelAngle +\n            collisions.left + collisions.right\n\n        if(newPosAngle > 2 * Math.PI) {\n            newPosAngle -= 2 * Math.PI\n        } else if(newPosAngle < 0) {\n            newPosAngle += 2 * Math.PI\n        }\n\n        const newCameraR = ((state.cameraR * constants.CAMERA_INERTIA + newPosR) /\n                            (constants.CAMERA_INERTIA + 1))\n\n        var angleDiff = newPosAngle - state.cameraAngle\n        if(angleDiff > Math.PI) {\n            angleDiff -= 2 * Math.PI\n        } else if(angleDiff < - Math.PI) {\n            angleDiff += 2 * Math.PI\n        }\n\n        var newCameraAngle = state.cameraAngle + angleDiff / constants.CAMERA_INERTIA\n        if(newCameraAngle > 2 * Math.PI) {\n            newCameraAngle -= 2 * Math.PI\n        } else if(newCameraAngle < 0) {\n            newCameraAngle += 2 * Math.PI\n        }\n\n        let newDebounce = state.debounce\n        if(state.keys.size === 0) {\n            newDebounce = 0\n        } else if(state.debounce < constants.TOUCH_DEBOUNCE_LIMIT) {\n            newDebounce += 1\n        }\n\n        return Object.assign({}, state, {\n            velAngle: newVelAngle, velR: newVelR,\n            posAngle: newPosAngle, posR: newPosR,\n            cameraAngle: newCameraAngle, cameraR: newCameraR,\n            debounce: newDebounce,\n        })\n\n    case LEVEL_WIN:\n        return Object.assign({}, state, {\n            posR: constants.PLANET_RADIUS, cameraR: constants.PLANET_RADIUS })\n\n    default:\n        return state\n    }\n}\n\nexport default player\n","export const normalize = (angle) => {\n    if(angle > Math.PI) {\n        return angle - 2 * Math.PI\n    }\n    if(angle < - Math.PI) {\n        return angle + 2 * Math.PI\n    }\n    return angle\n}\n","export const pointsInCircle = (\n    numPoints, maxRadius, minRadius = 0, minDistance = 0, uniform = true) => {\n        var points = []\n        while(points.length < numPoints) {\n            const angle = Math.random()*2*Math.PI\n            var u\n            if(uniform) {\n                u = Math.random() + Math.random()\n            } else {\n                u = Math.pow(Math.random(), 3)\n            }\n            const r = (u > 1) ? 2 - u : u\n            const radius = r * (maxRadius - minRadius) + minRadius\n            if(radius > minRadius) {\n                const posX = Math.round(radius * Math.cos(angle))\n                const posY = Math.round(radius * Math.sin(angle))\n\n                var clear = true\n                if(minDistance > 0) {\n                    for(const point of points) {\n                        if(Math.abs(point.posX - posX) +\n                           Math.abs(point.posY - posY) < minDistance) {\n                            clear = false\n                            break\n                        }\n                    }\n                }\n                if(clear) {\n                    points.push({ angle: angle, r: radius, posX: posX, posY: posY})\n                }\n            }\n        }\n        return points\n    }\n","import { pointsInCircle } from '../utils/random'\nimport constants from '../constants'\nimport { LEVEL_WIN, RESET_LEVEL } from '../actions'\n\nconst getPlanetRadius = (wins) => (\n    constants.PLANET_RADIUS\n)\n\nconst getGoalRadius = (wins) => (\n    constants.LEVEL_RADIUS * 1.5 ** wins\n)\n\nconst generateLevel = (wins) => {\n    return pointsInCircle(\n        constants.PLATFORMS,\n        getGoalRadius(wins),\n        getPlanetRadius(wins),\n        60, false)\n}\n\nconst defaultWins = 0\n\nvar defaultState = { level: generateLevel(defaultWins),\n                     wins: defaultWins,\n                     planetRadius: getPlanetRadius(defaultWins),\n                     goalRadius: getGoalRadius(defaultWins) }\n\nconst level = (state = Object.assign({}, defaultState), action) => {\n    var newWins = state.wins\n    if (action.type === LEVEL_WIN) {\n        newWins += 1\n    }\n    if (action.type === LEVEL_WIN || action.type === RESET_LEVEL) {\n        return Object.assign({}, state, {\n                level: generateLevel(newWins),\n                wins: newWins,\n                planetRadius: getPlanetRadius(newWins),\n            goalRadius: getGoalRadius(newWins)})\n    }\n\n    return state\n}\n\nexport default level\n","import { GAME_TICK } from '../actions'\nimport player from './player'\nimport level from './level'\n\nconst rootReducer = (state = {} , action) => {\n    switch(action.type) {\n        case GAME_TICK:\n            return {\n                player: player(state.player, action, state.level),\n                level: level(state.level, action)\n            }\n\n        default:\n            return {\n                player: player(state.player, action),\n                level: level(state.level, action)\n            }\n    }\n}\n\nexport default rootReducer\n","export class Component {\n    constructor(getState) {\n        this.context = document.createElement('canvas').getContext(\"2d\")\n        this.getState = getState\n        this.currentValue = undefined\n        this.updateCanvas = false\n        this.updatePosition = false\n    }\n\n    shouldComponentUpdate() {\n        const previousValue = this.currentValue\n        this.currentValue = this.getState()\n\n        this.updateCanvas = this.shouldCanvasUpdate(\n            previousValue, this.currentValue)\n        this.updatePosition = this.shouldPositionUpdate(\n            previousValue, this.currentValue)\n        return this.updateCanvas || this.updatePosition\n    }\n\n    shouldCanvasUpdate(previousValue, currentValue) {\n        return this.updateCanvas = previousValue !== currentValue\n    }\n\n    shouldPositionUpdate(previousValue, currentValue) {\n        return this.updatePosition = previousValue !== currentValue\n    }\n\n    render() {\n        throw new Error(\"Component class shall not be instantiated directly\")\n    }\n}\n\n","import { Component } from './index'\nimport constants from '../constants'\n\nclass Player extends Component {\n    shouldCanvasUpdate(previousValue, currentValue) {\n        if(previousValue === undefined) {\n            return true\n        }\n\n        return this.updateCanvas = (\n            previousValue.player.posAngle !== currentValue.player.posAngle ||\n            previousValue.player.posR !== currentValue.player.posR\n        )\n    }\n\n    shouldPositionUpdate(previousValue, currentValue) {\n        if(previousValue === undefined) {\n            return true\n        }\n\n        return this.updatePosition = (\n            previousValue.player.posAngle !== currentValue.player.posAngle ||\n            previousValue.player.posR !== currentValue.player.posR ||\n            previousValue.player.cameraAngle !== currentValue.player.cameraAngle ||\n            previousValue.player.cameraR !== currentValue.player.cameraR\n        )\n    }\n\n    render() {\n        const state = this.getState()\n        if(this.updateCanvas) {\n            this.context.fillStyle = \"#007DFF\"\n            const canvas = this.context.canvas\n            this.context.clearRect(0, 0, canvas.width, canvas.height)\n            this.context.save()\n            this.context.translate(\n                constants.PLAYER_WIDTH  * 2,\n                constants.PLAYER_HEIGHT  * 2\n            )\n            this.context.rotate(state.player.posAngle)\n            this.context.fillRect(\n                - constants.PLAYER_HEIGHT / 2,\n                - constants.PLAYER_WIDTH / 2,\n                constants.PLAYER_HEIGHT,\n                constants.PLAYER_WIDTH\n            )\n            this.context.restore()\n        }\n        return {\n            canvas: this.context.canvas,\n            angle: state.player.posAngle,\n            r: state.player.posR,\n            offsetX: constants.PLAYER_WIDTH * 2,\n            offsetY: constants.PLAYER_HEIGHT * 2\n        }\n    }\n\n    renderToContext(context, state, scale) {\n        const wins = state.level.wins\n        context.save()\n        context.fillStyle = \"#007DFF\"\n        context.rotate(state.player.posAngle)\n        context.translate(state.player.posR * scale, 0)\n        context.fillRect(\n            - constants.PLAYER_HEIGHT / 2 * scale,\n            - constants.PLAYER_WIDTH / 2 * scale,\n            constants.PLAYER_HEIGHT * scale,\n            constants.PLAYER_WIDTH * scale\n        )\n        context.fillStyle = \"#FFFFFF\"\n        for(var i = 0; i < wins; i++) {\n            var y = Math.floor(i / 2 + 1)\n            var x = Math.floor(i % 2 + 1)\n            context.fillRect(\n                - (constants.PLAYER_HEIGHT / 2 - constants.PLAYER_HEIGHT / 4 * y + 2) * scale,\n                - (constants.PLAYER_WIDTH / 2 - constants.PLAYER_WIDTH / 3 * x + 2) * scale,\n                4 * scale,\n                4 * scale\n            )\n        }\n        context.restore()\n    }\n}\n\nexport default Player\n","import { Component } from './index'\nimport constants from '../constants'\nimport { pointsInCircle } from '../utils/random'\n\nclass Map extends Component {\n    constructor(getState) {\n        super(getState)\n        this.context.canvas.width = constants.LEVEL_RADIUS * 2 + 100\n        this.context.canvas.height = constants.LEVEL_RADIUS * 2 + 100\n        this.center = constants.LEVEL_RADIUS + 50\n        const numShapes = 1000\n        this.points = pointsInCircle(numShapes, constants.PLANET_RADIUS - 5)\n        this.randoms = []\n        for(var i = 0; i < this.points.length; i++) {\n            this.randoms.push(Math.random())\n        }\n\n        this.context.canvas.width = 100\n        this.context.canvas.height = 100\n        //this.renderToContext(this.context, this.center, getState())\n    }\n\n    shouldCanvasUpdate(previousValue, currentValue) {\n        return this.updateCanvas = false\n    }\n\n    shouldPositionUpdate(previousValue, currentValue) {\n        return this.updatePosition = false\n    }\n\n    render() {\n        return {\n            canvas: this.context.canvas,\n            angle: 0,\n            r: 0,\n            offsetX: this.center,\n            offsetY: this.center,\n        }\n    }\n\n    renderToContext(context, state, scale) {\n        renderPlatforms(context, state.level.level, scale)\n\n        context.fillStyle = \"#666666\"\n        context.beginPath()\n        context.arc(0, 0, state.level.planetRadius * scale, 0, 2 * Math.PI)\n        context.fill()\n\n        context.strokeStyle = \"#00FF00\"\n        context.lineWidth = 10\n        context.beginPath()\n        context.arc(0, 0, state.level.goalRadius * scale, 0, 2 * Math.PI)\n        context.stroke()\n\n        for(var i = 0; i < this.points.length; i++) {\n            const point = this.points[i]\n            const random = this.randoms[i]\n\n            context.fillStyle =\n                \"hsl(0, 0%, \" + Math.round(random * 100) + \"%)\"\n            context.fillRect(\n                point.posX * scale,\n                point.posY * scale,\n                5 * scale,\n                5 * scale\n            )\n        }\n    }\n}\n\nfunction renderPlatforms(context, level, scale) {\n    context.fillStyle = \"#999999\"\n\n    for(const point of level) {\n        context.save()\n\n        context.rotate(point.angle)\n        context.fillRect((point.r - constants.PLATFORM_SIDE / 2) * scale,\n                         - constants.PLATFORM_SIDE / 2 * scale,\n                         constants.PLATFORM_SIDE * scale,\n                         constants.PLATFORM_SIDE * scale)\n        context.restore()\n    }\n}\n\nexport default Map\n","import { applyMiddleware, createStore } from 'redux'\nimport { createLogger } from 'redux-logger'\n\nimport './index.css'\nimport rootReducer from './reducers/index'\nimport { gameTick, keyDown, keyUp, touches, levelWin, resetLevel } from './actions/index'\nimport Player from './components/Player'\nimport Map from './components/Map'\n\nconst components = [Map, Player]\n\nconst init = () => {\n    var root = document.getElementById('root')\n    var canvas = document.createElement('canvas')\n    canvas.width = window.innerWidth\n    canvas.height = window.innerHeight\n    scale = Math.min(canvas.width / 1920, canvas.height / 1080)\n\n    window.onresize = (event) => {\n        canvas.width = window.innerWidth\n        canvas.height = window.innerHeight\n        scale = Math.min(canvas.width / 1920, canvas.height / 1080)\n    }\n\n    root.appendChild(canvas)\n    var context = canvas.getContext(\"2d\")\n    return context\n}\nvar scale = 1\n\nvar currentValue\nconst handleChange = (getState, context) => () => {\n    const previousValue = currentValue\n    currentValue = getState()\n\n    if(currentValue !== previousValue) {\n        const shouldUpdateCanvas = componentInstances.reduce(\n            (shouldUpdate, componentInstance) =>\n                (shouldUpdate || componentInstance.shouldComponentUpdate()),\n            false)\n        if(shouldUpdateCanvas) {\n            context.fillStyle = \"#000\"\n            context.fillRect(0, 0, context.canvas.width, context.canvas.height)\n            context.save()\n            const canvas = context.canvas\n            context.translate(canvas.width / 2, canvas.height / 2)\n            context.scale(1, -1)\n            context.translate(0, -currentValue.player.cameraR * scale)\n            const rotation = -currentValue.player.cameraAngle + Math.PI / 2\n            context.rotate(rotation)\n\n            for(const componentInstance of componentInstances) {\n                componentInstance.renderToContext(context, currentValue, scale)\n            }\n\n            context.restore()\n        }\n    }\n}\n\nvar context = init()\n\nvar predicate = (getState, action) =>\n    (action.type !== \"RENDER_TICK\" && action.type !== \"GAME_TICK\")\n\nvar logger = createLogger({predicate: predicate})\nvar store\nif(process.env.NODE_ENV === \"development\") {\n    store = createStore(rootReducer, applyMiddleware(logger))\n} else {\n    store = createStore(rootReducer)\n}\n\nconst componentInstances = components.map(\n    (component) => new component(store.getState))\n\nconst render = handleChange(store.getState, context)\n\nconst animationTicker = (timestamp) => {\n    render()\n    window.requestAnimationFrame(animationTicker)\n}\nwindow.requestAnimationFrame(animationTicker)\n\nwindow.setInterval(() => {\n    const state = store.getState()\n    if(state.player.posR > state.level.goalRadius) {\n        store.dispatch(levelWin())\n    }\n    store.dispatch(gameTick())\n}, 10)\n\nwindow.onkeydown = (event) => {\n    if(event.key === \"r\") {\n        store.dispatch(resetLevel())\n    }\n    store.dispatch(keyDown(event.key))\n}\nwindow.onkeyup = (event) => store.dispatch(keyUp(event.key))\n\ndocument.body.addEventListener('touchstart', (event) => {\n    event.preventDefault()\n    store.dispatch(touches(event.touches, window.innerWidth, window.innerHeight))\n}, { passive: false })\n\ndocument.body.addEventListener('touchend', (event) => {\n    event.preventDefault()\n    store.dispatch(touches(event.touches, window.innerWidth, window.innerHeight))\n}, { passive: false })\n\ndocument.body.addEventListener('touchcancel', (event) => {\n    event.preventDefault()\n    store.dispatch(touches(event.touches, window.innerWidth, window.innerHeight))\n}, { passive: false })\n"],"sourceRoot":""}