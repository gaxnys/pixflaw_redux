{"version":3,"sources":["actions/index.js","constants.js","index.js","reducers/player.js","utils/trig.js","utils/random.js","reducers/level.js","reducers/index.js","components/index.js","components/Player.js","components/Map.js","components/Background.js"],"names":["touches","windowWidth","windowHeight","type","constants","ACCELERATION","JUMP_ACCELERATION","RUN_ACCELERATION","VELOCITY_LOSS","PLANET_MASS","PLAYER_WIDTH","PLAYER_HEIGHT","PLATFORM_SIDE","SPEED_LIMIT","DOWN_CONSTANT","POINTS","BACKGROUND_RADIUS","LEVEL_RADIUS","PLANET_RADIUS","PLATFORMS","CAMERA_INERTIA","TOUCH_DEBOUNCE_LIMIT","FLY_ACCELERATION","GROUND_FRICTION","AIR_FRICTION","currentValue","store","keyToDirection","calculateAcceleration","keys","posR","colliding","accAngle","accR","verticalAcc","horizontalAcc","Math","atan","r","pow","angle","checkCollisions","posAngle","platforms","sides","up","left","down","right","almost","playerWidthPlatform","playerAnglePlatform","playerHeightPlatform","platform","radiusDiff","angleDiff","PI","abs","tan","player","newKeys","state","Set","velR","velAngle","cameraR","cameraAngle","debounce","action","levelState","add","key","Object","assign","delete","length","has","clientX","collisions","level","collidingIsh","planetRadius","newAcc","newVelR","min","newPosR","friction","newVelAngle","frictionAcc","sign","newPosAngle","newCameraR","newCameraAngle","newDebounce","size","pointsInCircle","numPoints","maxRadius","minRadius","minDistance","uniform","points","u","random","radius","posX","round","cos","posY","sin","clear","point","push","getPlanetRadius","wins","getGoalRadius","generateLevel","defaultState","goalRadius","newWins","rootReducer","Component","getState","this","context","document","createElement","getContext","undefined","updateCanvas","updatePosition","previousValue","shouldCanvasUpdate","shouldPositionUpdate","Error","Player","fillStyle","canvas","clearRect","width","height","save","translate","rotate","fillRect","restore","offsetX","offsetY","i","y","floor","x","Map","center","randoms","beginPath","arc","fill","strokeStyle","lineWidth","stroke","components","root","getElementById","window","innerWidth","innerHeight","onresize","event","appendChild","init","createLogger","predicate","createStore","componentInstances","map","component","render","reduce","shouldUpdate","componentInstance","shouldComponentUpdate","scale","rotation","renderToContext","requestAnimationFrame","animationTicker","timestamp","setInterval","dispatch","onkeydown","onkeyup","body","addEventListener","preventDefault","passive"],"mappings":"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","file":"static/js/main.b16be036.chunk.js","sourcesContent":["export const RENDER_TICK = 'RENDER_TICK'\nexport const renderTick = () => ({\n    type: RENDER_TICK\n})\n\nexport const GAME_TICK = 'GAME_TICK'\nexport const gameTick = (scale) => ({\n    type: GAME_TICK,\n    scale\n})\n\nexport const KEY_DOWN = 'KEY_DOWN'\nexport const keyDown = (key) => ({\n    type: KEY_DOWN,\n    key\n})\n\nexport const KEY_UP = 'KEY_UP'\nexport const keyUp = (key) => ({\n    type: KEY_UP,\n    key\n})\n\nexport const TOUCHES = 'TOUCHES'\nexport const touches = (touches, windowWidth, windowHeight) => ({\n    type: TOUCHES,\n    touches,\n    windowWidth,\n    windowHeight\n})\n\nexport const LEVEL_WIN = 'LEVEL_WIN'\nexport const levelWin = () => ({\n    type: LEVEL_WIN\n})\n\nexport const RESET_LEVEL = 'RESET_LEVEL'\nexport const resetLevel = () => ({\n    type: RESET_LEVEL\n})\n","const constants = {\n    ACCELERATION: 0.3,\n    JUMP_ACCELERATION: 3,\n    RUN_ACCELERATION: 0.1,\n    VELOCITY_LOSS: 10,\n    PLANET_MASS: 400000,\n    PLAYER_WIDTH: 20,\n    PLAYER_HEIGHT: 30,\n    PLATFORM_SIDE: 40,\n    SPEED_LIMIT: 10,\n    DOWN_CONSTANT: 0.1,\n\n    POINTS: 20000,\n    BACKGROUND_RADIUS: 4000,\n    LEVEL_RADIUS: 4000,\n    PLANET_RADIUS: 3000,\n    PLATFORMS: 1000,\n    CAMERA_INERTIA: 20,\n\n    TOUCH_DEBOUNCE_LIMIT: 10,\n}\n\nconstants.FLY_ACCELERATION = constants.RUN_ACCELERATION / 2\nconstants.GROUND_FRICTION = constants.RUN_ACCELERATION / 2\nconstants.AIR_FRICTION = constants.GROUND_FRICTION / 2\n\nexport default constants\n","import { applyMiddleware, createStore } from 'redux'\nimport { createLogger } from 'redux-logger'\n\nimport './index.css'\nimport rootReducer from './reducers/index'\nimport { gameTick, keyDown, keyUp, touches, levelWin, resetLevel } from './actions/index'\nimport Player from './components/Player'\nimport Map from './components/Map'\nimport Background from './components/Background'\n\nconst components = [Background, Map, Player]\n\nconst init = () => {\n    var root = document.getElementById('root')\n    var canvas = document.createElement('canvas')\n    canvas.width = window.innerWidth\n    canvas.height = window.innerHeight\n\n    window.onresize = (event) => {\n        canvas.width = window.innerWidth\n        canvas.height = window.innerHeight\n    }\n\n    root.appendChild(canvas)\n    var context = canvas.getContext(\"2d\")\n    return context\n}\n\nvar currentValue\nconst handleChange = (getState, context) => () => {\n    const previousValue = currentValue\n    currentValue = getState()\n\n    if(currentValue !== previousValue) {\n        const shouldUpdateCanvas = componentInstances.reduce(\n            (shouldUpdate, componentInstance) =>\n                (shouldUpdate || componentInstance.shouldComponentUpdate()),\n            false)\n        if(shouldUpdateCanvas) {\n            context.fillStyle = \"#000\"\n            context.fillRect(0, 0, context.canvas.width, context.canvas.height)\n            context.save()\n            const canvas = context.canvas\n            context.translate(canvas.width / 2, canvas.height / 2)\n            context.scale(1, -1)\n            context.translate(0, -currentValue.player.cameraR)\n            const rotation = -currentValue.player.cameraAngle + Math.PI / 2\n            context.rotate(rotation)\n\n            for(const componentInstance of componentInstances) {\n                componentInstance.renderToContext(context, currentValue, 0)\n            }\n\n            context.restore()\n        }\n    }\n}\n\nvar context = init()\n\nvar predicate = (getState, action) =>\n    (action.type !== \"RENDER_TICK\" && action.type !== \"GAME_TICK\")\n\nvar logger = createLogger({predicate: predicate})\nvar store\nif(process.env.NODE_ENV === \"development\") {\n    store = createStore(rootReducer, applyMiddleware(logger))\n} else {\n    store = createStore(rootReducer)\n}\n\nconst componentInstances = components.map(\n    (component) => new component(store.getState))\n\nconst render = handleChange(store.getState, context)\n\nconst animationTicker = (timestamp) => {\n    render()\n    window.requestAnimationFrame(animationTicker)\n}\nwindow.requestAnimationFrame(animationTicker)\n\nwindow.setInterval(() => {\n    const state = store.getState()\n    if(state.player.posR > state.level.goalRadius) {\n        store.dispatch(levelWin())\n    }\n    store.dispatch(gameTick())\n}, 10)\n\nwindow.onkeydown = (event) => {\n    if(event.key === \"r\") {\n        store.dispatch(resetLevel())\n    }\n    store.dispatch(keyDown(event.key))\n}\nwindow.onkeyup = (event) => store.dispatch(keyUp(event.key))\n\ndocument.body.addEventListener('touchstart', (event) => {\n    event.preventDefault()\n    store.dispatch(touches(event.touches, window.innerWidth, window.innerHeight))\n}, { passive: false })\n\ndocument.body.addEventListener('touchend', (event) => {\n    event.preventDefault()\n    store.dispatch(touches(event.touches, window.innerWidth, window.innerHeight))\n}, { passive: false })\n\ndocument.body.addEventListener('touchcancel', (event) => {\n    event.preventDefault()\n    store.dispatch(touches(event.touches, window.innerWidth, window.innerHeight))\n}, { passive: false })\n","import {\n    GAME_TICK,\n    KEY_DOWN,\n    KEY_UP,\n    TOUCHES,\n    LEVEL_WIN,\n} from '../actions/index'\nimport constants from '../constants.js'\nimport { normalize } from '../utils/trig'\n\nconst keyToDirection = {\n    \"w\": \"up\",\n    \"ArrowUp\": \"up\",\n    \"a\": \"left\",\n    \"ArrowLeft\": \"left\",\n    \"s\": \"down\",\n    \"ArrowDown\": \"down\",\n    \"d\": \"right\",\n    \"ArrowRight\": \"right\",\n    \" \": \"up\",\n}\n\nconst calculateAcceleration = (keys, posR, colliding) => {\n    var accAngle = 0, accR = colliding ? 0 : -constants.DOWN_CONSTANT\n    var verticalAcc = 0\n    var horizontalAcc = constants.FLY_ACCELERATION\n    if(colliding) {\n        verticalAcc = constants.JUMP_ACCELERATION\n        horizontalAcc = constants.RUN_ACCELERATION\n    } else {\n        verticalAcc = constants.DOWN_CONSTANT\n    }\n    for(const key of keys){\n        switch(key) {\n            case \"up\":\n                accR += verticalAcc\n                break\n\n            case \"left\":\n                accAngle += Math.atan(horizontalAcc / posR)\n                break\n\n            case \"right\":\n                accAngle -= Math.atan(horizontalAcc / posR)\n                break\n\n            default:\n                break\n        }\n    }\n\n    accR -= constants.PLANET_MASS / Math.pow(posR, 2)\n\n    return { r: accR, angle: accAngle }\n}\n\nconst checkCollisions = (posR, posAngle, platforms) => {\n    var sides = { up: false, left: false, down: false, right: false, almost: false }\n    const playerWidthPlatform = constants.PLAYER_WIDTH / 2 + constants.PLATFORM_SIDE / 2\n    const playerAnglePlatform = Math.atan(playerWidthPlatform / posR)\n    const playerHeightPlatform = constants.PLAYER_HEIGHT / 2 + constants.PLATFORM_SIDE / 2\n    for(const platform of platforms) {\n        const radiusDiff = platform.r - posR\n        const angleDiff = normalize(platform.angle - posAngle)\n\n        sides.almost = sides.almost || (\n            Math.abs(radiusDiff) < playerHeightPlatform + 1 &&\n            Math.abs(angleDiff) < Math.atan((playerWidthPlatform - 3) / posR) &&\n            radiusDiff < 0)\n\n        if(Math.abs(radiusDiff) > playerHeightPlatform) {\n            continue\n        }\n        if(Math.abs(angleDiff) > playerAnglePlatform) {\n            continue\n        }\n        if(playerHeightPlatform - Math.abs(radiusDiff) <\n            playerWidthPlatform - Math.abs(posR * Math.tan(angleDiff))\n        ) {\n            if(radiusDiff >= 0)\n                sides.up = sides.up || Math.abs(radiusDiff) - playerHeightPlatform\n            else\n                sides.down = sides.down || playerHeightPlatform - Math.abs(radiusDiff)\n        } else {\n            if(angleDiff >= 0)\n                sides.left = sides.left || Math.abs(angleDiff) - playerAnglePlatform\n            else\n                sides.right = sides.right || playerAnglePlatform - Math.abs(angleDiff)\n        }\n    }\n    return sides\n}\n\nconst player = (\n    state = { keys: new Set(),\n              velR: 0, velAngle: 0,\n              posR: 3100, posAngle: Math.PI/2,\n              cameraR: 3100, cameraAngle: Math.PI/2,\n              debounce: 0\n    }, action, levelState\n) => {\n    var newKeys\n    switch(action.type) {\n    case KEY_DOWN:\n        newKeys = new Set(state.keys)\n        newKeys.add(keyToDirection[action.key])\n        return Object.assign({}, state, { keys: newKeys })\n\n    case KEY_UP:\n        newKeys = new Set(state.keys)\n        newKeys.delete(keyToDirection[action.key])\n        return Object.assign({}, state, { keys: newKeys })\n\n    case TOUCHES:\n        newKeys = new Set()\n        if(action.touches.length === 2) {\n            if(state.debounce === constants.TOUCH_DEBOUNCE_LIMIT) {\n                newKeys = new Set(state.keys)\n            }\n            newKeys.add(\"up\")\n        } else if(action.touches.length > 0) {\n            if(state.keys.has(\"up\")) {\n                newKeys.add(\"up\")\n            }\n\n            if(action.touches[0].clientX > action.windowWidth / 2) {\n                newKeys.add(\"right\")\n            } else {\n                newKeys.add(\"left\")\n            }\n        }\n\n        return Object.assign({}, state, { keys: newKeys })\n\n    case GAME_TICK:\n        const collisions = checkCollisions(state.posR, state.posAngle, levelState.level)\n        const collidingIsh =\n              (state.posR - constants.PLAYER_HEIGHT / 2 - 1 < levelState.planetRadius) || collisions.almost\n        const newAcc = calculateAcceleration(state.keys, state.posR, collidingIsh)\n\n        var newVelR = Math.min(state.velR + newAcc.r, constants.SPEED_LIMIT)\n        if((collisions.up && state.velR > 0) || (collisions.down && state.velR < 0)) {\n            newVelR = 0\n        }\n        var newPosR = state.posR + newVelR +\n            collisions.down + collisions.up\n\n        if(state.posR - constants.PLAYER_HEIGHT / 2 < levelState.planetRadius) {\n            newPosR = levelState.planetRadius + constants.PLAYER_HEIGHT / 2\n            newVelR = (newVelR < -constants.VELOCITY_LOSS) ? -(newVelR+constants.VELOCITY_LOSS) : 0\n            newVelR = 0\n        }\n\n        const friction = collidingIsh ? constants.GROUND_FRICTION : constants.AIR_FRICTION\n\n        var newVelAngle = state.velAngle + newAcc.angle\n\n        const frictionAcc = Math.sign(-state.velAngle) * friction\n        newVelAngle +=  Math.tan(frictionAcc / state.posR)\n\n        if(Math.abs(newVelAngle) < Math.tan(friction / state.posR)) {\n            newVelAngle = 0\n        }\n\n        if((collisions.left && state.velAngle > 0) || (collisions.right && state.velAngle < 0)) {\n            newVelAngle = 0\n        }\n        var newPosAngle = state.posAngle + newVelAngle +\n            collisions.left + collisions.right\n\n        if(newPosAngle > 2 * Math.PI) {\n            newPosAngle -= 2 * Math.PI\n        } else if(newPosAngle < 0) {\n            newPosAngle += 2 * Math.PI\n        }\n\n        const newCameraR = ((state.cameraR * constants.CAMERA_INERTIA + newPosR) /\n                            (constants.CAMERA_INERTIA + 1))\n\n        var angleDiff = newPosAngle - state.cameraAngle\n        if(angleDiff > Math.PI) {\n            angleDiff -= 2 * Math.PI\n        } else if(angleDiff < - Math.PI) {\n            angleDiff += 2 * Math.PI\n        }\n\n        var newCameraAngle = state.cameraAngle + angleDiff / constants.CAMERA_INERTIA\n        if(newCameraAngle > 2 * Math.PI) {\n            newCameraAngle -= 2 * Math.PI\n        } else if(newCameraAngle < 0) {\n            newCameraAngle += 2 * Math.PI\n        }\n\n        let newDebounce = state.debounce\n        if(state.keys.size === 0) {\n            newDebounce = 0\n        } else if(state.debounce < constants.TOUCH_DEBOUNCE_LIMIT) {\n            newDebounce += 1\n        }\n\n        return Object.assign({}, state, {\n            velAngle: newVelAngle, velR: newVelR,\n            posAngle: newPosAngle, posR: newPosR,\n            cameraAngle: newCameraAngle, cameraR: newCameraR,\n            debounce: newDebounce,\n        })\n\n    case LEVEL_WIN:\n        return Object.assign({}, state, {\n            posR: constants.PLANET_RADIUS, cameraR: constants.PLANET_RADIUS })\n\n    default:\n        return state\n    }\n}\n\nexport default player\n","export const normalize = (angle) => {\n    if(angle > Math.PI) {\n        return angle - 2 * Math.PI\n    }\n    if(angle < - Math.PI) {\n        return angle + 2 * Math.PI\n    }\n    return angle\n}\n","export const pointsInCircle = (\n    numPoints, maxRadius, minRadius = 0, minDistance = 0, uniform = true) => {\n        var points = []\n        while(points.length < numPoints) {\n            const angle = Math.random()*2*Math.PI\n            var u\n            if(uniform) {\n                u = Math.random() + Math.random()\n            } else {\n                u = Math.pow(Math.random(), 3)\n            }\n            const r = (u > 1) ? 2 - u : u\n            const radius = r * (maxRadius - minRadius) + minRadius\n            if(radius > minRadius) {\n                const posX = Math.round(radius * Math.cos(angle))\n                const posY = Math.round(radius * Math.sin(angle))\n\n                var clear = true\n                if(minDistance > 0) {\n                    for(const point of points) {\n                        if(Math.abs(point.posX - posX) +\n                           Math.abs(point.posY - posY) < minDistance) {\n                            clear = false\n                            break\n                        }\n                    }\n                }\n                if(clear) {\n                    points.push({ angle: angle, r: radius, posX: posX, posY: posY})\n                }\n            }\n        }\n        return points\n    }\n","import { pointsInCircle } from '../utils/random'\nimport constants from '../constants'\nimport { LEVEL_WIN, RESET_LEVEL } from '../actions'\n\nconst getPlanetRadius = (wins) => (\n    constants.PLANET_RADIUS\n)\n\nconst getGoalRadius = (wins) => (\n    constants.LEVEL_RADIUS * 1.5 ** wins\n)\n\nconst generateLevel = (wins) => {\n    return pointsInCircle(\n        constants.PLATFORMS,\n        getGoalRadius(wins),\n        getPlanetRadius(wins),\n        60, false)\n}\n\nconst defaultWins = 0\n\nvar defaultState = { level: generateLevel(defaultWins),\n                     wins: defaultWins,\n                     planetRadius: getPlanetRadius(defaultWins),\n                     goalRadius: getGoalRadius(defaultWins) }\n\nconst level = (state = Object.assign({}, defaultState), action) => {\n    var newWins = state.wins\n    if (action.type === LEVEL_WIN) {\n        newWins += 1\n    }\n    if (action.type === LEVEL_WIN || action.type === RESET_LEVEL) {\n        return Object.assign({}, state, {\n                level: generateLevel(newWins),\n                wins: newWins,\n                planetRadius: getPlanetRadius(newWins),\n            goalRadius: getGoalRadius(newWins)})\n    }\n\n    return state\n}\n\nexport default level\n","import { GAME_TICK } from '../actions'\nimport player from './player'\nimport level from './level'\n\nconst rootReducer = (state = {} , action) => {\n    switch(action.type) {\n        case GAME_TICK:\n            return {\n                player: player(state.player, action, state.level),\n                level: level(state.level, action)\n            }\n\n        default:\n            return {\n                player: player(state.player, action),\n                level: level(state.level, action)\n            }\n    }\n}\n\nexport default rootReducer\n","export class Component {\n    constructor(getState) {\n        this.context = document.createElement('canvas').getContext(\"2d\")\n        this.getState = getState\n        this.currentValue = undefined\n        this.updateCanvas = false\n        this.updatePosition = false\n    }\n\n    shouldComponentUpdate() {\n        const previousValue = this.currentValue\n        this.currentValue = this.getState()\n\n        this.updateCanvas = this.shouldCanvasUpdate(\n            previousValue, this.currentValue)\n        this.updatePosition = this.shouldPositionUpdate(\n            previousValue, this.currentValue)\n        return this.updateCanvas || this.updatePosition\n    }\n\n    shouldCanvasUpdate(previousValue, currentValue) {\n        return this.updateCanvas = previousValue !== currentValue\n    }\n\n    shouldPositionUpdate(previousValue, currentValue) {\n        return this.updatePosition = previousValue !== currentValue\n    }\n\n    render() {\n        throw new Error(\"Component class shall not be instantiated directly\")\n    }\n}\n\n","import { Component } from './index'\nimport constants from '../constants'\n\nclass Player extends Component {\n    shouldCanvasUpdate(previousValue, currentValue) {\n        if(previousValue === undefined) {\n            return true\n        }\n\n        return this.updateCanvas = (\n            previousValue.player.posAngle !== currentValue.player.posAngle ||\n            previousValue.player.posR !== currentValue.player.posR\n        )\n    }\n\n    shouldPositionUpdate(previousValue, currentValue) {\n        if(previousValue === undefined) {\n            return true\n        }\n\n        return this.updatePosition = (\n            previousValue.player.posAngle !== currentValue.player.posAngle ||\n            previousValue.player.posR !== currentValue.player.posR ||\n            previousValue.player.cameraAngle !== currentValue.player.cameraAngle ||\n            previousValue.player.cameraR !== currentValue.player.cameraR\n        )\n    }\n\n    render() {\n        const state = this.getState()\n        if(this.updateCanvas) {\n            this.context.fillStyle = \"#007DFF\"\n            const canvas = this.context.canvas\n            this.context.clearRect(0, 0, canvas.width, canvas.height)\n            this.context.save()\n            this.context.translate(\n                constants.PLAYER_WIDTH  * 2,\n                constants.PLAYER_HEIGHT  * 2\n            )\n            this.context.rotate(state.player.posAngle)\n            this.context.fillRect(\n                - constants.PLAYER_HEIGHT / 2,\n                - constants.PLAYER_WIDTH / 2,\n                constants.PLAYER_HEIGHT,\n                constants.PLAYER_WIDTH\n            )\n            this.context.restore()\n        }\n        return {\n            canvas: this.context.canvas,\n            angle: state.player.posAngle,\n            r: state.player.posR,\n            offsetX: constants.PLAYER_WIDTH * 2,\n            offsetY: constants.PLAYER_HEIGHT * 2\n        }\n    }\n\n    renderToContext(context, state) {\n        const wins = state.level.wins\n        context.save()\n        context.fillStyle = \"#007DFF\"\n        context.rotate(state.player.posAngle)\n        context.translate(state.player.posR, 0)\n        context.fillRect(\n            - constants.PLAYER_HEIGHT / 2,\n            - constants.PLAYER_WIDTH / 2,\n            constants.PLAYER_HEIGHT,\n            constants.PLAYER_WIDTH\n        )\n        context.fillStyle = \"#FFFFFF\"\n        for(var i = 0; i < wins; i++) {\n            var y = Math.floor(i / 2 + 1)\n            var x = Math.floor(i % 2 + 1)\n            context.fillRect(\n                - constants.PLAYER_HEIGHT / 2 + constants.PLAYER_HEIGHT / 4 * y - 2,\n                - constants.PLAYER_WIDTH / 2 + constants.PLAYER_WIDTH / 3 * x - 2,\n                4,\n                4\n            )\n        }\n        context.restore()\n    }\n}\n\nexport default Player\n","import { Component } from './index'\nimport constants from '../constants'\nimport { pointsInCircle } from '../utils/random'\n\nclass Map extends Component {\n    constructor(getState) {\n        super(getState)\n        this.context.canvas.width = constants.LEVEL_RADIUS * 2 + 100\n        this.context.canvas.height = constants.LEVEL_RADIUS * 2 + 100\n        this.center = constants.LEVEL_RADIUS + 50\n        const numShapes = 1000\n        this.points = pointsInCircle(numShapes, constants.PLANET_RADIUS - 5)\n        this.randoms = []\n        for(var i = 0; i < this.points.length; i++) {\n            this.randoms.push(Math.random())\n        }\n\n        this.context.canvas.width = 100\n        this.context.canvas.height = 100\n        //this.renderToContext(this.context, this.center, getState())\n    }\n\n    shouldCanvasUpdate(previousValue, currentValue) {\n        return this.updateCanvas = false\n    }\n\n    shouldPositionUpdate(previousValue, currentValue) {\n        return this.updatePosition = false\n    }\n\n    render() {\n        return {\n            canvas: this.context.canvas,\n            angle: 0,\n            r: 0,\n            offsetX: this.center,\n            offsetY: this.center,\n        }\n    }\n\n    renderToContext(context, state, center) {\n        context.fillStyle = \"#999999\"\n\n        for(const point of state.level.level) {\n            context.save()\n\n            context.rotate(point.angle)\n            context.fillRect(point.r - constants.PLATFORM_SIDE / 2,\n                             - constants.PLATFORM_SIDE / 2,\n                             constants.PLATFORM_SIDE,\n                             constants.PLATFORM_SIDE)\n            context.restore()\n        }\n\n        context.fillStyle = \"#666666\"\n        context.beginPath()\n        context.arc(center, center, state.level.planetRadius, 0, 2 * Math.PI)\n        context.fill()\n\n        context.strokeStyle = \"#00FF00\"\n        context.lineWidth = 10\n        context.beginPath()\n        context.arc(center, center, state.level.goalRadius, 0, 2 * Math.PI)\n        context.stroke()\n\n        for(var i = 0; i < this.points.length; i++) {\n            const point = this.points[i]\n            const random = this.randoms[i]\n\n            context.fillStyle =\n                \"hsl(0, 0%, \" + Math.round(random * 100) + \"%)\"\n            context.fillRect(center + point.posX, center + point.posY, 5, 5)\n        }\n    }\n}\n\nexport default Map\n","import { Component } from './index'\nimport { pointsInCircle } from '../utils/random'\nimport constants from '../constants'\n\nclass Background extends Component {\n    constructor(getState) {\n        super(getState)\n\n        this.points = pointsInCircle(constants.POINTS, constants.BACKGROUND_RADIUS)\n    }\n\n    shouldCanvasUpdate(previousValue, currentValue) {\n        return this.updateCanvas = false\n    }\n\n    shouldPositionUpdate(previousValue, currentValue) {\n        return this.updatePosition = false\n    }\n\n    renderToContext(context, state) {\n        context.fillStyle = \"#FFFFFF\"\n        const r = state.player.cameraR * 0.9 - constants.PLANET_RADIUS\n        const angle = state.player.cameraAngle\n        const offsetX = r * Math.cos(angle)\n        const offsetY = r * Math.sin(angle)\n        for(const point of this.points) {\n            const posX = Math.round(point.r * Math.cos(point.angle) + offsetX)\n            const posY = Math.round(point.r * Math.sin(point.angle) + offsetY)\n            context.fillRect(posX, posY, 1, 1)\n        }\n    }\n}\n\nexport default Background\n"],"sourceRoot":""}