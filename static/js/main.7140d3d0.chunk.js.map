{"version":3,"sources":["index.js","actions/index.js","reducers/player.js","constants.js","utils/trig.js","utils/random.js","reducers/level.js","reducers/index.js","components/index.js","components/Player.js","components/Map.js","components/Background.js"],"names":["currentValue","store","touches","windowWidth","windowHeight","type","keyToDirection","calculateAcceleration","keys","posR","colliding","accAngle","accR","verticalAcc","JETPACK_ACCELERATION","Math","pow","horizontalAcc","RUN_ACCELERATION","atan","r","angle","checkCollisions","posAngle","platforms","sides","up","left","down","right","almost","playerAnglePlatform","PLAYER_WIDTH","platform","radiusDiff","angleDiff","PI","abs","playerHeightPlatform","PLAYER_HEIGHT","tan","player","newKeys","state","Set","velR","velAngle","cameraR","cameraAngle","debounce","action","levelState","add","key","Object","assign","delete","length","has","clientX","collisions","level","collidingIsh","planetRadius","newAcc","newVelR","min","newPosR","friction","ACCELERATION","GROUND_FRICTION","newVelAngle","frictionAcc","sign","newPosAngle","newCameraR","newCameraAngle","newDebounce","size","pointsInCircle","numPoints","maxRadius","minRadius","minDistance","uniform","points","u","random","radius","posX","round","cos","posY","sin","clear","point","push","getGoalRadius","wins","generateLevel","defaultState","goalRadius","newWins","rootReducer","Component","getState","this","context","document","createElement","getContext","undefined","updateCanvas","updatePosition","previousValue","shouldCanvasUpdate","shouldPositionUpdate","Player","fillStyle","canvas","clearRect","width","height","save","translate","rotate","fillRect","restore","offsetX","offsetY","i","y","floor","x","Map","LEVEL_RADIUS","center","PLANET_RADIUS","randoms","PLATFORM_SIDE","beginPath","arc","fill","strokeStyle","lineWidth","stroke","components","root","getElementById","window","innerWidth","innerHeight","onresize","event","appendChild","init","createLogger","predicate","createStore","componentInstances","map","component","render","reduce","shouldUpdate","componentInstance","shouldComponentUpdate","scale","rotation","renderToContext","requestAnimationFrame","animationTicker","timestamp","setInterval","dispatch","onkeydown","onkeyup","body","addEventListener","preventDefault","passive"],"mappings":"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","file":"static/js/main.7140d3d0.chunk.js","sourcesContent":["import { applyMiddleware, createStore } from 'redux'\nimport { createLogger } from 'redux-logger'\n\nimport './index.css'\nimport rootReducer from './reducers/index'\nimport { renderTick, gameTick, keyDown, keyUp, touches, levelWin, resetLevel } from './actions/index'\nimport Player from './components/Player'\nimport Map from './components/Map'\nimport Background from './components/Background'\n\nconst components = [Background, Map, Player]\n\nconst init = () => {\n    var root = document.getElementById('root')\n    var canvas = document.createElement('canvas')\n    canvas.width = window.innerWidth\n    canvas.height = window.innerHeight\n\n    window.onresize = (event) => {\n        canvas.width = window.innerWidth\n        canvas.height = window.innerHeight\n    }\n\n    root.appendChild(canvas)\n    var context = canvas.getContext(\"2d\")\n    return context\n}\n\nvar currentValue\nconst handleChange = (getState, context) => () => {\n    const previousValue = currentValue\n    currentValue = getState()\n\n    if(currentValue !== previousValue) {\n        const shouldUpdateCanvas = componentInstances.reduce(\n            (shouldUpdate, componentInstance) =>\n                (shouldUpdate || componentInstance.shouldComponentUpdate()),\n            false)\n        if(shouldUpdateCanvas) {\n            context.fillStyle = \"#000\"\n            context.fillRect(0, 0, context.canvas.width, context.canvas.height)\n            context.save()\n            const canvas = context.canvas\n            context.translate(canvas.width / 2, canvas.height / 2)\n            context.scale(1, -1)\n            context.translate(0, -currentValue.player.cameraR)\n            const rotation = -currentValue.player.cameraAngle + Math.PI / 2\n            context.rotate(rotation)\n\n            for(const componentInstance of componentInstances) {\n                componentInstance.renderToContext(context, currentValue, 0)\n            }\n\n            context.restore()\n        }\n    }\n}\n\nvar context = init()\n\nvar predicate = (getState, action) =>\n    (action.type !== \"RENDER_TICK\" && action.type !== \"GAME_TICK\")\n\nvar logger = createLogger({predicate: predicate})\nvar store\nif(process.env.NODE_ENV === \"development\") {\n    store = createStore(rootReducer, applyMiddleware(logger))\n} else {\n    store = createStore(rootReducer)\n}\n\nconst componentInstances = components.map(\n    (component) => new component(store.getState))\n\nconst render = handleChange(store.getState, context)\n\nconst animationTicker = (timestamp) => {\n    render()\n    window.requestAnimationFrame(animationTicker)\n}\nwindow.requestAnimationFrame(animationTicker)\n\nwindow.setInterval(() => {\n    const state = store.getState()\n    if(state.player.posR > state.level.goalRadius) {\n        store.dispatch(levelWin())\n    }\n    store.dispatch(gameTick())\n}, 10)\n\nwindow.onkeydown = (event) => {\n    if(event.key === \"r\") {\n        store.dispatch(resetLevel())\n    }\n    store.dispatch(keyDown(event.key))\n}\nwindow.onkeyup = (event) => store.dispatch(keyUp(event.key))\n\ndocument.body.addEventListener('touchstart', (event) => {\n    event.preventDefault()\n    store.dispatch(touches(event.touches, window.innerWidth, window.innerHeight))\n}, { passive: false })\n\ndocument.body.addEventListener('touchend', (event) => {\n    event.preventDefault()\n    store.dispatch(touches(event.touches, window.innerWidth, window.innerHeight))\n}, { passive: false })\n\ndocument.body.addEventListener('touchcancel', (event) => {\n    event.preventDefault()\n    store.dispatch(touches(event.touches, window.innerWidth, window.innerHeight))\n}, { passive: false })\n","export const RENDER_TICK = 'RENDER_TICK'\nexport const renderTick = () => ({\n    type: RENDER_TICK\n})\n\nexport const GAME_TICK = 'GAME_TICK'\nexport const gameTick = (scale) => ({\n    type: GAME_TICK,\n    scale\n})\n\nexport const KEY_DOWN = 'KEY_DOWN'\nexport const keyDown = (key) => ({\n    type: KEY_DOWN,\n    key\n})\n\nexport const KEY_UP = 'KEY_UP'\nexport const keyUp = (key) => ({\n    type: KEY_UP,\n    key\n})\n\nexport const TOUCHES = 'TOUCHES'\nexport const touches = (touches, windowWidth, windowHeight) => ({\n    type: TOUCHES,\n    touches,\n    windowWidth,\n    windowHeight\n})\n\nexport const LEVEL_WIN = 'LEVEL_WIN'\nexport const levelWin = () => ({\n    type: LEVEL_WIN\n})\n\nexport const RESET_LEVEL = 'RESET_LEVEL'\nexport const resetLevel = () => ({\n    type: RESET_LEVEL\n})\n","import { RENDER_TICK, GAME_TICK, KEY_DOWN, KEY_UP, TOUCHES, LEVEL_WIN } from '../actions/index'\nimport { ACCELERATION, JUMP_ACCELERATION, JETPACK_ACCELERATION, RUN_ACCELERATION, FLY_ACCELERATION, GROUND_FRICTION, AIR_FRICTION, VELOCITY_LOSS, PLAYER_WIDTH, PLAYER_HEIGHT, PLATFORM_SIDE, PLANET_RADIUS, CAMERA_INERTIA, PLANET_MASS, SPEED_LIMIT, DOWN_CONSTANT, TOUCH_DEBOUNCE_LIMIT } from '../constants.js'\nimport { normalize } from '../utils/trig'\n\nconst keyToDirection = {\n    \"w\": \"up\",\n    \"ArrowUp\": \"up\",\n    \"a\": \"left\",\n    \"ArrowLeft\": \"left\",\n    \"s\": \"down\",\n    \"ArrowDown\": \"down\",\n    \"d\": \"right\",\n    \"ArrowRight\": \"right\",\n    \" \": \"up\",\n}\n\nconst calculateAcceleration = (keys, posR, colliding) => {\n    var accAngle = 0, accR = 0\n    var verticalAcc = JETPACK_ACCELERATION * PLANET_MASS / Math.pow(posR, 2)\n    var horizontalAcc = FLY_ACCELERATION\n    if(colliding) {\n        verticalAcc = JUMP_ACCELERATION\n        horizontalAcc = RUN_ACCELERATION\n    }\n    for(const key of keys){\n        switch(key) {\n            case \"up\":\n                accR += verticalAcc\n                break\n\n            case \"left\":\n                accAngle += Math.atan(horizontalAcc / posR)\n                break\n\n            case \"down\":\n                accR -= DOWN_CONSTANT\n                break\n\n            case \"right\":\n                accAngle -= Math.atan(horizontalAcc / posR)\n                break\n\n            default:\n                break\n        }\n    }\n\n    accR -= PLANET_MASS / Math.pow(posR, 2)\n\n    return { r: accR, angle: accAngle }\n}\n\nconst checkCollisions = (posR, posAngle, platforms) => {\n    var sides = { up: false, left: false, down: false, right: false, almost: false }\n    const playerWidthPlatform = PLAYER_WIDTH / 2 + PLATFORM_SIDE / 2\n    const playerAnglePlatform = Math.atan(playerWidthPlatform / posR)\n    const playerHeightPlatform = PLAYER_HEIGHT / 2 + PLATFORM_SIDE / 2\n    for(const platform of platforms) {\n        const radiusDiff = platform.r - posR\n        const angleDiff = normalize(platform.angle - posAngle)\n\n        sides.almost = sides.almost || (\n            Math.abs(radiusDiff) < playerHeightPlatform + 1 &&\n            Math.abs(angleDiff) < Math.atan((playerWidthPlatform - 3) / posR) &&\n            radiusDiff < 0)\n\n        if(Math.abs(radiusDiff) > playerHeightPlatform) {\n            continue\n        }\n        if(Math.abs(angleDiff) > playerAnglePlatform) {\n            continue\n        }\n        if(playerHeightPlatform - Math.abs(radiusDiff) <\n            playerWidthPlatform - Math.abs(posR * Math.tan(angleDiff))\n        ) {\n            if(radiusDiff >= 0)\n                sides.up = sides.up || Math.abs(radiusDiff) - playerHeightPlatform\n            else\n                sides.down = sides.down || playerHeightPlatform - Math.abs(radiusDiff)\n        } else {\n            if(angleDiff >= 0)\n                sides.left = sides.left || Math.abs(angleDiff) - playerAnglePlatform\n            else\n                sides.right = sides.right || playerAnglePlatform - Math.abs(angleDiff)\n        }\n    }\n    return sides\n}\n\nconst player = (\n    state = { keys: new Set(),\n              velR: 0, velAngle: 0,\n              posR: 3100, posAngle: Math.PI/2,\n              cameraR: 3100, cameraAngle: Math.PI/2,\n              debounce: 0\n    }, action, levelState\n) => {\n    var newKeys\n    switch(action.type) {\n        case KEY_DOWN:\n            newKeys = new Set(state.keys)\n            newKeys.add(keyToDirection[action.key])\n            return Object.assign({}, state, { keys: newKeys })\n\n        case KEY_UP:\n            newKeys = new Set(state.keys)\n            newKeys.delete(keyToDirection[action.key])\n            return Object.assign({}, state, { keys: newKeys })\n\n        case TOUCHES:\n            newKeys = new Set()\n            if(action.touches.length === 2) {\n                if(state.debounce === TOUCH_DEBOUNCE_LIMIT) {\n                    newKeys = new Set(state.keys)\n                }\n                newKeys.add(\"up\")\n            } else if(action.touches.length > 0) {\n                if(state.keys.has(\"up\")) {\n                    newKeys.add(\"up\")\n                }\n\n                if(action.touches[0].clientX > action.windowWidth / 2) {\n                    newKeys.add(\"right\")\n                } else {\n                    newKeys.add(\"left\")\n                }\n            }\n            \n            return Object.assign({}, state, { keys: newKeys })\n\n        case GAME_TICK:\n            const collisions = checkCollisions(state.posR, state.posAngle, levelState.level)\n            const collidingIsh =\n                (state.posR - PLAYER_HEIGHT / 2 - 1 < levelState.planetRadius) || collisions.almost\n            const newAcc = calculateAcceleration(state.keys, state.posR, collidingIsh)\n\n            var newVelR = Math.min(state.velR + newAcc.r, SPEED_LIMIT)\n            if(collisions.up && state.velR > 0 || collisions.down && state.velR < 0) {\n                newVelR = 0\n            }\n            var newPosR = state.posR + newVelR +\n                          collisions.down + collisions.up\n\n            if(state.posR - PLAYER_HEIGHT / 2 < levelState.planetRadius) {\n                newPosR = levelState.planetRadius + PLAYER_HEIGHT / 2\n                newVelR = (newVelR < -VELOCITY_LOSS) ? -(newVelR+VELOCITY_LOSS) : 0\n                newVelR = 0\n            }\n\n            const friction = collidingIsh ? GROUND_FRICTION : AIR_FRICTION\n\n            var newVelAngle = state.velAngle + newAcc.angle\n\n            const frictionAcc = Math.sign(-state.velAngle) * friction\n            newVelAngle +=  Math.tan(frictionAcc / state.posR)\n\n            if(Math.abs(newVelAngle) < Math.tan(friction / state.posR)) {\n                newVelAngle = 0\n            }\n\n            if(collisions.left && state.velAngle > 0 || collisions.right && state.velAngle < 0) {\n                newVelAngle = 0\n            }\n            var newPosAngle = state.posAngle + newVelAngle +\n                              collisions.left + collisions.right\n\n            if(newPosAngle > 2 * Math.PI) {\n                newPosAngle -= 2 * Math.PI\n            } else if(newPosAngle < 0) {\n                newPosAngle += 2 * Math.PI\n            }\n\n            const newCameraR = ((state.cameraR * CAMERA_INERTIA + newPosR) /\n                (CAMERA_INERTIA + 1))\n\n            var angleDiff = newPosAngle - state.cameraAngle\n            if(angleDiff > Math.PI) {\n                angleDiff -= 2 * Math.PI\n            } else if(angleDiff < - Math.PI) {\n                angleDiff += 2 * Math.PI\n            }\n\n            var newCameraAngle = state.cameraAngle + angleDiff / CAMERA_INERTIA\n            if(newCameraAngle > 2 * Math.PI) {\n                newCameraAngle -= 2 * Math.PI\n            } else if(newCameraAngle < 0) {\n                newCameraAngle += 2 * Math.PI\n            }\n\n            let newDebounce = state.debounce\n            if(state.keys.size == 0) {\n                newDebounce = 0\n            } else if(state.debounce < TOUCH_DEBOUNCE_LIMIT) {\n                newDebounce += 1\n            }\n\n            return Object.assign({}, state, {\n                velAngle: newVelAngle, velR: newVelR,\n                posAngle: newPosAngle, posR: newPosR,\n                cameraAngle: newCameraAngle, cameraR: newCameraR,\n                debounce: newDebounce,\n            })\n\n        case LEVEL_WIN:\n            return Object.assign({}, state, {\n                posR: PLANET_RADIUS, cameraR: PLANET_RADIUS })\n\n        default:\n            return state\n    }\n}\n\nexport default player\n","export const ACCELERATION = 0.5\nexport const JUMP_ACCELERATION = 6\nexport const JETPACK_ACCELERATION = 0.7\nexport const RUN_ACCELERATION = 0.3\nexport const FLY_ACCELERATION = RUN_ACCELERATION / 2\nexport const VELOCITY_LOSS = 10\nexport const GRAVITY = ACCELERATION / 2\nexport const PLANET_MASS = 4000000\nexport const GROUND_FRICTION = ACCELERATION / 2\nexport const AIR_FRICTION = GROUND_FRICTION / 2\nexport const PLAYER_WIDTH = 20\nexport const PLAYER_HEIGHT = 30\nexport const PLATFORM_SIDE = 40\nexport const SPEED_LIMIT = 10\nexport const DOWN_CONSTANT = 1\n\nexport const POINTS = 20000\nexport const BACKGROUND_RADIUS = 4000\nexport const LEVEL_RADIUS = 4000\nexport const PLANET_RADIUS = 3000\nexport const PLATFORMS = 1000\nexport const CAMERA_INERTIA = 20\n\nexport const TOUCH_DEBOUNCE_LIMIT = 10\n","export const normalize = (angle) => {\n    if(angle > Math.PI) {\n        return angle - 2 * Math.PI\n    }\n    if(angle < - Math.PI) {\n        return angle + 2 * Math.PI\n    }\n    return angle\n}\n","export const pointsInCircle = (\n    numPoints, maxRadius, minRadius = 0, minDistance = 0, uniform = true) => {\n        var points = []\n        while(points.length < numPoints) {\n            const angle = Math.random()*2*Math.PI\n            var u\n            if(uniform) {\n                u = Math.random() + Math.random()\n            } else {\n                u = Math.pow(Math.random(), 3)\n            }\n            const r = (u > 1) ? 2 - u : u\n            const radius = r * (maxRadius - minRadius) + minRadius\n            if(radius > minRadius) {\n                const posX = Math.round(radius * Math.cos(angle))\n                const posY = Math.round(radius * Math.sin(angle))\n\n                var clear = true\n                if(minDistance > 0) {\n                    for(const point of points) {\n                        if(Math.abs(point.posX - posX) +\n                           Math.abs(point.posY - posY) < minDistance) {\n                            clear = false\n                            break\n                        }\n                    }\n                }\n                if(clear) {\n                    points.push({ angle: angle, r: radius, posX: posX, posY: posY})\n                }\n            }\n        }\n        return points\n    }\n","import { pointsInCircle } from '../utils/random'\nimport { LEVEL_RADIUS, PLANET_RADIUS, PLATFORMS } from '../constants'\nimport { LEVEL_WIN, RESET_LEVEL } from '../actions'\n\nconst getDifficulty = (wins) => (\n    wins + 4.0\n)\n\nconst getPlanetRadius = (wins) => (\n    PLANET_RADIUS\n)\n\nconst getGoalRadius = (wins) => (\n    LEVEL_RADIUS * 1.5 ** wins\n)\n\nconst generateLevel = (wins) => {\n    const difficulty = getDifficulty(wins)\n    return pointsInCircle(\n        PLATFORMS,\n        getGoalRadius(wins),\n        getPlanetRadius(wins) ,\n        60, false)\n}\n\nconst defaultWins = 0\n\nvar defaultState = { level: generateLevel(defaultWins),\n                     wins: defaultWins,\n                     planetRadius: getPlanetRadius(defaultWins),\n                     goalRadius: getGoalRadius(defaultWins) }\n\nconst level = (state = Object.assign({}, defaultState), action) => {\n    var newWins = state.wins\n    switch(action.type) {\n        case LEVEL_WIN:\n            newWins += 1\n\n        case RESET_LEVEL:\n            return Object.assign({}, state, {\n                level: generateLevel(newWins),\n                wins: newWins,\n                planetRadius: getPlanetRadius(newWins),\n                goalRadius: getGoalRadius(newWins)})\n\n        default:\n            return state\n    }\n}\n\nexport default level\n","import { GAME_TICK } from '../actions'\nimport player from './player'\nimport level from './level'\n\nconst rootReducer = (state = {} , action) => {\n    switch(action.type) {\n        case GAME_TICK:\n            return {\n                player: player(state.player, action, state.level),\n                level: level(state.level, action)\n            }\n\n        default:\n            return {\n                player: player(state.player, action),\n                level: level(state.level, action)\n            }\n    }\n}\n\nexport default rootReducer\n","import { PLAYER_WIDTH, PLAYER_HEIGHT } from '../constants'\n\nexport class Component {\n    constructor(getState) {\n        this.context = document.createElement('canvas').getContext(\"2d\")\n        this.getState = getState\n        this.currentValue = undefined\n        this.updateCanvas = false\n        this.updatePosition = false\n    }\n\n    shouldComponentUpdate() {\n        const previousValue = this.currentValue\n        this.currentValue = this.getState()\n\n        this.updateCanvas = this.shouldCanvasUpdate(\n            previousValue, this.currentValue)\n        this.updatePosition = this.shouldPositionUpdate(\n            previousValue, this.currentValue)\n        return this.updateCanvas || this.updatePosition\n    }\n\n    shouldCanvasUpdate(previousValue, currentValue) {\n        return this.updateCanvas = previousValue !== currentValue\n    }\n\n    shouldPositionUpdate(previousValue, currentValue) {\n        return this.updatePosition = previousValue !== currentValue\n    }\n\n    render() {\n        throw \"Component class shall not be instantiated directly\"\n    }\n}\n\n","import { Component } from './index'\nimport { PLAYER_WIDTH, PLAYER_HEIGHT } from '../constants'\n\nclass Player extends Component {\n    shouldCanvasUpdate(previousValue, currentValue) {\n        if(previousValue === undefined) {\n            return true\n        }\n\n        return this.updateCanvas = (\n            previousValue.player.posAngle !== currentValue.player.posAngle ||\n            previousValue.player.posR !== currentValue.player.posR\n        )\n    }\n\n    shouldPositionUpdate(previousValue, currentValue) {\n        if(previousValue === undefined) {\n            return true\n        }\n\n        return this.updatePosition = (\n            previousValue.player.posAngle !== currentValue.player.posAngle ||\n            previousValue.player.posR !== currentValue.player.posR ||\n            previousValue.player.cameraAngle !== currentValue.player.cameraAngle ||\n            previousValue.player.cameraR !== currentValue.player.cameraR\n        )\n    }\n\n    render() {\n        const state = this.getState()\n        if(this.updateCanvas) {\n            this.context.fillStyle = \"#007DFF\"\n            const canvas = this.context.canvas\n            this.context.clearRect(0, 0, canvas.width, canvas.height)\n            this.context.save()\n            this.context.translate(PLAYER_WIDTH  * 2,\n                                   PLAYER_HEIGHT  * 2)\n            this.context.rotate(state.player.posAngle)\n            this.context.fillRect(- PLAYER_HEIGHT / 2,\n                                - PLAYER_WIDTH / 2,\n                                  PLAYER_HEIGHT,\n                                  PLAYER_WIDTH)\n            this.context.restore()\n        }\n        return {\n            canvas: this.context.canvas,\n            angle: state.player.posAngle,\n            r: state.player.posR,\n            offsetX: PLAYER_WIDTH * 2,\n            offsetY: PLAYER_HEIGHT * 2\n        }\n    }\n\n    renderToContext(context, state) {\n        const wins = state.level.wins\n        context.save()\n        context.fillStyle = \"#007DFF\"\n        context.rotate(state.player.posAngle)\n        context.translate(state.player.posR, 0)\n        context.fillRect(- PLAYER_HEIGHT / 2,\n                       - PLAYER_WIDTH / 2,\n                         PLAYER_HEIGHT,\n                         PLAYER_WIDTH)\n        context.fillStyle = \"#FFFFFF\"\n        for(var i = 0; i < wins; i++) {\n            var y = Math.floor(i / 2 + 1)\n            var x = Math.floor(i % 2 + 1)\n            context.fillRect(- PLAYER_HEIGHT / 2 + PLAYER_HEIGHT / 4 * y - 2,\n                           - PLAYER_WIDTH / 2 + PLAYER_WIDTH / 3 * x - 2,\n                             4, 4)\n        }\n        context.restore()\n    }\n}\n\nexport default Player\n","import { Component } from './index'\nimport { PLANET_RADIUS, LEVEL_RADIUS, PLATFORM_SIDE } from '../constants'\nimport { pointsInCircle } from '../utils/random'\n\nclass Map extends Component {\n    constructor(getState) {\n        super(getState)\n        this.context.canvas.width = LEVEL_RADIUS * 2 + 100\n        this.context.canvas.height = LEVEL_RADIUS * 2 + 100\n        this.center = LEVEL_RADIUS + 50\n        const numShapes = 1000\n        this.points = pointsInCircle(numShapes, PLANET_RADIUS - 5)\n        this.randoms = []\n        for(var i = 0; i < this.points.length; i++) {\n            this.randoms.push(Math.random())\n        }\n\n        this.context.canvas.width = 100\n        this.context.canvas.height = 100\n        //this.renderToContext(this.context, this.center, getState())\n    }\n\n    shouldCanvasUpdate(previousValue, currentValue) {\n        return this.updateCanvas = false\n    }\n\n    shouldPositionUpdate(previousValue, currentValue) {\n        return this.updatePosition = false\n    }\n\n    render() {\n        const state = this.getState()\n        return {\n            canvas: this.context.canvas,\n            angle: 0,\n            r: 0,\n            offsetX: this.center,\n            offsetY: this.center,\n        }\n    }\n\n    renderToContext(context, state, center) {\n        context.fillStyle = \"#999999\"\n\n        for(const point of state.level.level) {\n            context.save()\n            const angleDiff = Math.tan(PLATFORM_SIDE / 2 / point.r)\n\n            context.rotate(point.angle)\n            context.fillRect(point.r - PLATFORM_SIDE / 2, - PLATFORM_SIDE / 2, PLATFORM_SIDE, PLATFORM_SIDE)\n            context.restore()\n        }\n\n        context.fillStyle = \"#666666\"\n        context.beginPath()\n        context.arc(center, center, state.level.planetRadius, 0, 2 * Math.PI)\n        context.fill()\n\n        context.strokeStyle = \"#00FF00\"\n        context.lineWidth = 10\n        context.beginPath()\n        context.arc(center, center, state.level.goalRadius, 0, 2 * Math.PI)\n        context.stroke()\n\n        for(var i = 0; i < this.points.length; i++) {\n            const point = this.points[i]\n            const random = this.randoms[i]\n\n            context.fillStyle =\n                \"hsl(0, 0%, \" + Math.round(random * 100) + \"%)\"\n            context.fillRect(center + point.posX, center + point.posY, 5, 5)\n        }\n    }\n}\n\nexport default Map\n","import { Component } from './index'\nimport { pointsInCircle } from '../utils/random'\nimport { POINTS, BACKGROUND_RADIUS, PLANET_RADIUS } from '../constants'\n\nclass Background extends Component {\n    constructor(getState) {\n        super(getState)\n\n        this.points = pointsInCircle(POINTS, BACKGROUND_RADIUS)\n    }\n\n    shouldCanvasUpdate(previousValue, currentValue) {\n        return this.updateCanvas = false\n    }\n\n    shouldPositionUpdate(previousValue, currentValue) {\n        return this.updatePosition = false\n    }\n\n    renderToContext(context, state) {\n        context.fillStyle = \"#FFFFFF\"\n        const r = state.player.cameraR * 0.9 - PLANET_RADIUS\n        const angle = state.player.cameraAngle\n        const offsetX = r * Math.cos(angle)\n        const offsetY = r * Math.sin(angle)\n        for(const point of this.points) {\n            const posX = Math.round(point.r * Math.cos(point.angle) + offsetX)\n            const posY = Math.round(point.r * Math.sin(point.angle) + offsetY)\n            context.fillRect(posX, posY, 1, 1)\n        }\n    }\n}\n\nexport default Background\n"],"sourceRoot":""}